# [æœ€ç»ˆè®¾è®¡] AIå·¥å…·è°ƒç”¨æ¶æ„ - v3.0 (2025-07-24)

> **ç‰ˆæœ¬è¯´æ˜**: æœ¬æ–‡æ¡£æè¿°äº†AIå·¥å…·è°ƒç”¨åŠŸèƒ½çš„æœ€ç»ˆæ¶æ„è®¾è®¡ã€‚è¯¥è®¾è®¡å°† ServiceContainer å‡çº§ä¸ºç»Ÿä¸€çš„"èƒ½åŠ›ä¸­å¿ƒ"ï¼Œå°† IntelligentToolCallingService å®šä½ä¸º"æ™ºèƒ½ç¼–æ’å¼•æ“"ï¼Œå®ç°æ›´æ¸…æ™°çš„èŒè´£åˆ†ç¦»å’Œæ›´å¼ºå¤§çš„æ‰©å±•èƒ½åŠ›ã€‚

## ğŸ¯ è®¾è®¡ç›®æ ‡ (Goals)

### ä¸»è¦ç›®æ ‡
1. **ç»Ÿä¸€èƒ½åŠ›ç®¡ç†**: ServiceContainer æˆä¸ºæ‰€æœ‰æœåŠ¡ã€å·¥å…·ã€å‡½æ•°çš„ç»Ÿä¸€æ³¨å†Œå’Œæ‰§è¡Œä¸­å¿ƒ
2. **æ™ºèƒ½å·¥ä½œæµç¼–æ’**: IntelligentToolCallingService ä¸“æ³¨äºå¤æ‚çš„ AI-å·¥å…·äº¤äº’æµç¨‹
3. **æ¸…æ™°èŒè´£è¾¹ç•Œ**: æ¯ä¸ªç»„ä»¶éƒ½æœ‰æ˜ç¡®ã€å•ä¸€çš„èŒè´£ï¼Œé¿å…åŠŸèƒ½é‡å 
4. **é¢å‘æœªæ¥æ‰©å±•**: æ”¯æŒå·¥å…·é“¾ã€å¹¶è¡Œè°ƒç”¨ã€æ¡ä»¶åˆ†æ”¯ç­‰é«˜çº§åœºæ™¯

### æ ¸å¿ƒåŸåˆ™
- **ServiceContainer**: ç®¡ç†"èƒ½åŠ›"ï¼Œä¸ç®¡ç†"æµç¨‹"
- **IntelligentToolCallingService**: ç®¡ç†"æ™ºèƒ½ç¼–æ’"ï¼Œä¸ç®¡ç†"å·¥å…·æ‰§è¡Œ"
- **Governor**: ç®¡ç†"ç”¨æˆ·äº¤äº’"ï¼Œä¸ç®¡ç†"åº•å±‚é€»è¾‘"

## ğŸŒŠ æ–°æ¶æ„æ¦‚è§ˆ (Architecture Overview)

### åˆ†å±‚èŒè´£å›¾
```mermaid
graph TD
    subgraph "ç”¨æˆ·äº¤äº’å±‚ (User Interface Layer)"
        Governor("<b>Governor</b><br/>ç”¨æˆ·æŸ¥è¯¢æ¥æ”¶<br/>ä¼šè¯ç®¡ç†<br/>UIäº¤äº’")
    end

    subgraph "æ™ºèƒ½ç¼–æ’å±‚ (Intelligent Orchestration Layer)"
        ITC("<b>IntelligentToolCallingService</b><br/>AIå†³ç­–ä¸å·¥å…·é€‰æ‹©<br/>å¤æ‚å·¥ä½œæµç¼–æ’<br/>ç»“æœæ•´åˆä¸è¾“å‡º")
    end
    
    subgraph "èƒ½åŠ›ç®¡ç†å±‚ (Capability Management Layer)"
        SC("<b>ServiceContainer</b><br/>æœåŠ¡æ³¨å†Œä¸å‘ç°<br/>å·¥å…·å®šä¹‰ä¸æ‰§è¡Œ<br/>ä¾èµ–è§£æä¸æ³¨å…¥")
    end
    
    subgraph "åŸºç¡€æœåŠ¡å±‚ (Foundation Services Layer)"
        direction LR
        LLM("LLMService")
        Dispatcher("DispatcherService")
        Analyzer("AnalyzerServices")
        Others("å…¶ä»–æœåŠ¡...")
    end

    Governor -->|"ç®€å•å§”æ‰˜"| ITC
    ITC -->|"è·å–å·¥å…·åˆ—è¡¨"| SC
    ITC -->|"æ‰§è¡Œå…·ä½“å·¥å…·"| SC
    ITC -->|"AIå†³ç­–è°ƒç”¨"| LLM
    ITC -->|"å·¥å…·é€‰æ‹©ç­–ç•¥"| Dispatcher
    SC -->|"æœåŠ¡å®ä¾‹è·å–"| LLM
    SC -->|"æœåŠ¡å®ä¾‹è·å–"| Analyzer
    SC -->|"æœåŠ¡å®ä¾‹è·å–"| Others
```

### æ ¸å¿ƒå·¥ä½œæµç¨‹
```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·
    participant Gov as Governor
    participant ITC as IntelligentToolCallingService
    participant SC as ServiceContainer
    participant LLM as LLMService
    participant Tool as å…·ä½“å·¥å…·æœåŠ¡

    User->>Gov: "å¸®æˆ‘åˆ†æç‹å°æ˜çš„é—®é¢˜"
    Gov->>ITC: ExecuteQueryStreamAsync(query, onChunk)
    
    ITC->>SC: GetFrameworkToolDefinitions()
    SC-->>ITC: [å·¥å…·åˆ—è¡¨]
    
    ITC->>LLM: "é€‰æ‹©åˆé€‚çš„å·¥å…·" (Function Calling)
    LLM-->>ITC: {toolName: "get_pawn_details", params: {...}}
    
    ITC->>SC: ExecuteToolAsync("get_pawn_details", params)
    SC->>Tool: æ‰§è¡Œå…·ä½“åˆ†æ
    Tool-->>SC: åˆ†æç»“æœ
    SC-->>ITC: ToolExecutionResult
    
    ITC->>LLM: "åŸºäºå·¥å…·ç»“æœç”Ÿæˆå›å¤" (æµå¼)
    LLM-->>ITC: æµå¼æ–‡æœ¬å—
    ITC-->>Gov: onChunk(æ–‡æœ¬å—)
    Gov-->>User: å®æ—¶æ˜¾ç¤ºç»“æœ
```

## ğŸ—ï¸ è¯¦ç»†ç»„ä»¶è®¾è®¡

### 1. ServiceContainer - ç»Ÿä¸€èƒ½åŠ›ä¸­å¿ƒ

#### æ ¸å¿ƒèŒè´£
- **æœåŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†**: æ³¨å†Œã€è·å–ã€é”€æ¯æ‰€æœ‰æœåŠ¡å®ä¾‹
- **å·¥å…·å®šä¹‰ç®¡ç†**: æ³¨å†Œã€å‘ç°ã€éªŒè¯æ‰€æœ‰å¯æ‰§è¡Œå·¥å…·
- **å·¥å…·æ‰§è¡Œå¼•æ“**: å‚æ•°éªŒè¯ã€ç±»å‹è½¬æ¢ã€æ–¹æ³•è°ƒç”¨ã€ç»“æœå¤„ç†
- **ä¾èµ–è§£æ**: è‡ªåŠ¨è§£ææœåŠ¡é—´ä¾èµ–å…³ç³»

#### å…³é”®æ¥å£è®¾è®¡
```csharp
public class ServiceContainer
{
    // === æœåŠ¡ç®¡ç† (ç°æœ‰åŠŸèƒ½) ===
    public T GetService<T>() where T : class;
    public void RegisterService<TInterface, TImplementation>(TImplementation instance);
    
    // === å·¥å…·ç®¡ç† (æ–°å¢åŠŸèƒ½) ===
    public void RegisterServiceWithTools<TInterface, TImplementation>(
        TImplementation implementation,
        params ExecutableToolBuilder<TInterface>[] toolBuilders);
    
    public List<FrameworkAITool> GetFrameworkToolDefinitions();
    public async Task<ToolExecutionResult> ExecuteToolAsync(string toolName, Dictionary<string, object> parameters);
    
    // === èƒ½åŠ›æŸ¥è¯¢ (æ–°å¢åŠŸèƒ½) ===
    public bool HasTool(string toolName);
    public ExecutableTool GetToolDefinition(string toolName);
    public List<string> GetToolsForService<T>();
}
```

#### å·¥å…·æ³¨å†Œç¤ºä¾‹
```csharp
private void RegisterDefaultServices()
{
    // æ³¨å†Œåˆ†ææœåŠ¡åŠå…¶å·¥å…·
    RegisterServiceWithTools<IColonyAnalyzer, ColonyAnalyzer>(
        new ColonyAnalyzer(),
        
        ExecutableToolBuilder<IColonyAnalyzer>
            .Create("get_colony_summary", "è·å–æ®–æ°‘åœ°æ•´ä½“çŠ¶å†µæ¦‚è§ˆ")
            .WithImplementation(async (analyzer, params) => 
                await analyzer.GetQuickStatusSummaryAsync()),
                
        ExecutableToolBuilder<IColonyAnalyzer>
            .Create("analyze_colony_mood", "åˆ†ææ®–æ°‘åœ°æ•´ä½“å¿ƒæƒ…çŠ¶æ€")
            .WithParameter("detailed", "boolean", "æ˜¯å¦è¿”å›è¯¦ç»†åˆ†æ", false, true)
            .WithImplementation(async (analyzer, params) => 
                await analyzer.AnalyzeMoodAsync((bool)params.GetValueOrDefault("detailed", true)))
    );
    
    RegisterServiceWithTools<IPawnAnalyzer, PawnAnalyzer>(
        new PawnAnalyzer(),
        
        ExecutableToolBuilder<IPawnAnalyzer>
            .Create("get_pawn_details", "è·å–æŒ‡å®šæ®–æ°‘è€…è¯¦ç»†ä¿¡æ¯")
            .WithParameter("pawnName", "string", "æ®–æ°‘è€…å§“å", true)
            .WithParameter("includeSkills", "boolean", "åŒ…å«æŠ€èƒ½ä¿¡æ¯", false, true)
            .WithImplementation(async (analyzer, params) =>
            {
                var name = (string)params["pawnName"];
                var includeSkills = (bool)params.GetValueOrDefault("includeSkills", true);
                return await analyzer.GetPawnDetailsAsync(name, includeSkills);
            })
    );
}
```

### 2. IntelligentToolCallingService - æ™ºèƒ½ç¼–æ’å¼•æ“

#### æ ¸å¿ƒèŒè´£
- **AIäº¤äº’ç®¡ç†**: ä¸LLMè¿›è¡Œå¤šè½®å¯¹è¯ï¼Œå¤„ç†Function Calling
- **å·¥ä½œæµç¼–æ’**: å•å·¥å…·ã€å·¥å…·é“¾ã€å¹¶è¡Œå·¥å…·ã€æ¡ä»¶åˆ†æ”¯ç­‰å¤æ‚åœºæ™¯
- **ä¸Šä¸‹æ–‡ç®¡ç†**: ç»´æŠ¤å¯¹è¯ä¸Šä¸‹æ–‡ï¼Œå¤„ç†å·¥å…·é—´æ•°æ®ä¼ é€’
- **ç»“æœæ•´åˆ**: å°†å¤šä¸ªå·¥å…·ç»“æœæ•´åˆæˆç”¨æˆ·å‹å¥½çš„æœ€ç»ˆå›å¤
- **æµå¼è¾“å‡º**: ç®¡ç†å®æ—¶çš„ç”¨æˆ·åé¦ˆå’Œè¿›åº¦æ˜¾ç¤º

#### å…³é”®æ¥å£è®¾è®¡
```csharp
public interface IIntelligentToolCallingService
{
    // === åŸºç¡€èƒ½åŠ› ===
    Task ExecuteQueryStreamAsync(string query, Action<string> onChunk, CancellationToken cancellationToken = default);
    Task<string> ExecuteQueryAsync(string query, CancellationToken cancellationToken = default);
    
    // === é«˜çº§èƒ½åŠ› (æœªæ¥æ‰©å±•) ===
    Task ExecuteToolChainStreamAsync(string query, Action<string> onChunk, ToolChainOptions options = null, CancellationToken cancellationToken = default);
    Task ExecuteParallelToolsStreamAsync(string query, Action<string> onChunk, ParallelToolOptions options = null, CancellationToken cancellationToken = default);
    
    // === è§„åˆ’èƒ½åŠ› (è°ƒè¯•æ”¯æŒ) ===
    Task<ExecutionPlan> PlanExecutionAsync(string query, CancellationToken cancellationToken = default);
}
```

#### æ‰§è¡Œç­–ç•¥
```csharp
public enum ExecutionStrategy
{
    SimpleConversation,  // æ— éœ€å·¥å…·ï¼Œç›´æ¥å¯¹è¯
    SingleTool,          // å•å·¥å…·æ‰§è¡Œ
    SequentialTools,     // é¡ºåºæ‰§è¡Œå¤šä¸ªå·¥å…·
    ParallelTools,       // å¹¶è¡Œæ‰§è¡Œå¤šä¸ªå·¥å…·
    ConditionalFlow,     // åŸºäºç»“æœçš„æ¡ä»¶åˆ†æ”¯
    IterativeRefinement  // è¿­ä»£ä¼˜åŒ–ï¼ˆå¤šè½®å·¥å…·è°ƒç”¨ï¼‰
}
```

#### é«˜çº§å·¥ä½œæµç¤ºä¾‹ï¼ˆâš ï¸è­¦å‘Šï¼Œç›®å‰ä¸è¦å°è¯•å®æ–½ï¼Œè¿™ä¼šå¯¼è‡´åŸå§‹ç‰ˆæœ¬è¿‡äºå¤æ‚ï¼ŒBugå¢å¤šï¼Œåœ¨æ²¡æœ‰æˆæƒçš„æƒ…å†µä¸‹ï¼Œä»»ä½•äººã€ä»»ä½•AIéƒ½ä¸å¾—å®æ–½è¿™éƒ¨åˆ†å†…å®¹ï¼Œè¿™éƒ¨åˆ†ä»…ä¾›å±•ç¤ºã€è®¨è®ºï¼ï¼ï¼å†ä¸‰æ³¨æ„ï¼âš ï¸ï¼‰
```csharp
// å·¥å…·é“¾æ‰§è¡Œï¼šåˆ†æé—®é¢˜ â†’ æŸ¥æ‰¾è§£å†³æ–¹æ¡ˆ â†’ ç”Ÿæˆå»ºè®®
public async Task ExecuteToolChainStreamAsync(string query, Action<string> onChunk, ToolChainOptions options = null, CancellationToken cancellationToken = default)
{
    // 1. AIè§„åˆ’é˜¶æ®µ
    onChunk?.Invoke("ğŸ¤” æ­£åœ¨åˆ†ææ‚¨çš„è¯·æ±‚å¹¶åˆ¶å®šæ‰§è¡Œè®¡åˆ’...\n");
    var plan = await PlanExecutionAsync(query, cancellationToken);
    onChunk?.Invoke($"ğŸ“‹ æ‰§è¡Œè®¡åˆ’ï¼š{plan.Strategy}ï¼Œå…±{plan.Steps.Count}ä¸ªæ­¥éª¤\n\n");

    // 2. é¡ºåºæ‰§è¡Œé˜¶æ®µ
    var context = new WorkflowContext();
    foreach (var step in plan.Steps)
    {
        onChunk?.Invoke($"ğŸ”§ æ‰§è¡Œæ­¥éª¤{step.Number}ï¼š{step.Purpose}\n");
        
        // ä½¿ç”¨å‰é¢æ­¥éª¤çš„ç»“æœä¸°å¯Œå½“å‰æ­¥éª¤çš„å‚æ•°
        var enrichedParams = EnrichParametersWithContext(step.Parameters, context);
        
        // æ‰§è¡Œå·¥å…·
        var result = await CoreServices.ExecuteToolAsync(step.ToolName, enrichedParams);
        if (result.Success)
        {
            context.AddStepResult(step.Number, result.Result);
            onChunk?.Invoke($"âœ… æ­¥éª¤{step.Number}å®Œæˆ\n");
        }
        else
        {
            onChunk?.Invoke($"âŒ æ­¥éª¤{step.Number}å¤±è´¥ï¼š{result.ErrorMessage}\n");
            // é”™è¯¯æ¢å¤é€»è¾‘
            await HandleStepFailure(step, result, context, onChunk, cancellationToken);
        }
    }

    // 3. ç»“æœæ•´åˆé˜¶æ®µ
    onChunk?.Invoke("\nğŸ“ æ­£åœ¨æ•´åˆåˆ†æç»“æœ...\n");
    await GenerateComprehensiveResponse(query, context, onChunk, cancellationToken);
}
```

### 3. Governor - ç”¨æˆ·äº¤äº’å…¥å£

#### æ ¸å¿ƒèŒè´£
- **æŸ¥è¯¢æ¥æ”¶**: æ¥æ”¶ç”¨æˆ·çš„è‡ªç„¶è¯­è¨€æŸ¥è¯¢
- **ç®€å•å§”æ‰˜**: å°†å¤æ‚é€»è¾‘å§”æ‰˜ç»™IntelligentToolCallingService
- **ä¼šè¯ç®¡ç†**: ç»´æŠ¤ä¸ç”¨æˆ·çš„å¯¹è¯çŠ¶æ€
- **ç»“æœè½¬å‘**: å°†å¤„ç†ç»“æœè½¬å‘ç»™ç”¨æˆ·ç•Œé¢

#### ç®€åŒ–åçš„å®ç°
```csharp
public class Governor : OfficerBase
{
    private readonly IIntelligentToolCallingService _toolCallingService;

    public Governor()
    {
        _toolCallingService = CoreServices.IntelligentToolCalling;
    }

    public async Task HandleUserQueryStreamAsync(string userQuery, Action<string> onChunk, CancellationToken cancellationToken = default)
    {
        if (_toolCallingService == null)
        {
            onChunk?.Invoke("æ™ºèƒ½å·¥å…·è°ƒç”¨æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ã€‚");
            return;
        }
        
        // ç®€å•å§”æ‰˜ï¼Œæ‰€æœ‰å¤æ‚é€»è¾‘ç”± IntelligentToolCallingService å¤„ç†
        await _toolCallingService.ExecuteQueryStreamAsync(userQuery, onChunk, cancellationToken);
    }

    public async Task<string> HandleUserQueryAsync(string userQuery, CancellationToken cancellationToken = default)
    {
        if (_toolCallingService == null)
        {
            return "æ™ºèƒ½å·¥å…·è°ƒç”¨æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ã€‚";
        }
        
        return await _toolCallingService.ExecuteQueryAsync(userQuery, cancellationToken);
    }
}
```

## ğŸ”§ æŠ€æœ¯å®ç°è¦ç‚¹

### 1. é¿å…ä¸Frameworkå†²çª
- **ç±»å‹å‘½ååŒºåˆ†**: `ExecutableTool` (Core) vs `AITool` (Framework)
- **èŒè´£æ¸…æ™°åˆ†ç¦»**: Frameworkè´Ÿè´£AIæ¥å£ï¼ŒCoreè´Ÿè´£æ‰§è¡Œé€»è¾‘
- **å…¼å®¹æ€§ä¿è¯**: Coreçš„å·¥å…·å¯ä»¥è½¬æ¢ä¸ºFrameworkçš„AIToolæ ¼å¼

### 2. ç±»å‹å®‰å…¨ä¿è¯
```csharp
// ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥
ExecutableToolBuilder<IPawnAnalyzer>
    .Create("get_pawn_details", "è·å–æ®–æ°‘è€…ä¿¡æ¯")
    .WithParameter("pawnName", "string", "æ®–æ°‘è€…å§“å", required: true)
    .WithImplementation(async (analyzer, params) => 
    {
        // è¿™é‡Œæœ‰å®Œæ•´çš„ç±»å‹å®‰å…¨ä¿è¯
        var name = (string)params["pawnName"]; // å‚æ•°éªŒè¯å·²åœ¨æ¡†æ¶å±‚å®Œæˆ
        return await analyzer.GetPawnDetailsAsync(name);
    });
```

### 3. é”™è¯¯å¤„ç†å’Œæ¢å¤
```csharp
public class ToolExecutionResult
{
    public bool Success { get; set; }
    public string Result { get; set; }
    public string ErrorMessage { get; set; }
    public TimeSpan ExecutionTime { get; set; }
    public Dictionary<string, object> Metadata { get; set; }
    
    public static ToolExecutionResult Success(string result, TimeSpan? duration = null) => new() { Success = true, Result = result, ExecutionTime = duration ?? TimeSpan.Zero };
    public static ToolExecutionResult Error(string error) => new() { Success = false, ErrorMessage = error };
    public static ToolExecutionResult NotFound(string toolName) => new() { Success = false, ErrorMessage = $"å·¥å…· '{toolName}' æœªæ‰¾åˆ°" };
}
```

### 4. ç»Ÿä¸€LLMè°ƒç”¨ç½‘å…³ (æ–°å¢åŸåˆ™)
- **åŸåˆ™**: `Core` æ¨¡å—å†…éƒ¨æ‰€æœ‰å¯¹å¤§è¯­è¨€æ¨¡å‹çš„è°ƒç”¨ï¼Œ**å¿…é¡»**é€šè¿‡ `Core` è‡ªå·±çš„ `ILLMService` æ¥å£è¿›è¡Œã€‚
- **ç¦æ­¢**: ä»»ä½•æœåŠ¡ï¼ˆåŒ…æ‹¬ `IntelligentToolCallingService`ï¼‰éƒ½ä¸åº”ç›´æ¥è°ƒç”¨ `RimAI.Framework.API.RimAIApi`ã€‚
- **ç†ç”±**:
    - **ç»Ÿä¸€æ§åˆ¶ç‚¹**: å…è®¸æˆ‘ä»¬åœ¨ `Core` å±‚é¢æ·»åŠ ç»Ÿä¸€çš„æ—¥å¿—ã€ç¼“å­˜ã€ç›‘æ§æˆ–è¯·æ±‚/å“åº”æ‹¦æˆªé€»è¾‘ã€‚
    - **è§£è€¦**: ä½¿ `Core` æ¨¡å—ä¸ `Framework` çš„å…·ä½“å®ç°è§£è€¦ï¼Œæœªæ¥å³ä½¿ `Framework` APIå˜æ›´ï¼Œæˆ‘ä»¬ä¹Ÿåªéœ€ä¿®æ”¹ `Core.LLMService` çš„å®ç°ï¼Œè€Œä¸ç”¨ä¿®æ”¹æ‰€æœ‰è°ƒç”¨ç‚¹ã€‚
    - **èŒè´£æ¸…æ™°**: `Core.LLMService` ä½œä¸º `Core` æ¨¡å—è®¿é—® `Framework` LLMèƒ½åŠ›çš„**å”¯ä¸€**ç½‘å…³ã€‚

```csharp
// æ­£ç¡®çš„è°ƒç”¨æ–¹å¼ (åœ¨ IntelligentToolCallingService ä¸­)
public class IntelligentToolCallingService : IIntelligentToolCallingService
{
    private readonly ILLMService _llmService;

    public IntelligentToolCallingService()
    {
        // ä»CoreServicesè·å–Coreè‡ªå·±çš„LLMæœåŠ¡
        _llmService = CoreServices.LLMService; 
    }

    private async Task SomeMethod()
    {
        // âœ… å¿…é¡»é€šè¿‡ Core çš„æœåŠ¡æ¥å£è°ƒç”¨
        await _llmService.SendStreamingMessageAsync(...); 
    }
}

// é”™è¯¯çš„è°ƒç”¨æ–¹å¼
public class SomeOtherService
{
    private async Task SomeMethod()
    {
        // âŒ ç¦æ­¢ç›´æ¥è°ƒç”¨ Framework çš„é™æ€ API
        await RimAIApi.SendMessageStreamAsync(...); 
    }
}
```

### 5. æ¶æ„ç®€åŒ–å†³ç­–ï¼šç§»é™¤Dispatcherå±‚ (æ–°å¢å†³ç­–)
- **é—®é¢˜åˆ†æ**: ç»è¿‡å®¡æŸ¥ï¼Œ`IDispatcherService` æŠ½è±¡å±‚å½“å‰å”¯ä¸€çš„æœ‰æ•ˆå®ç°æ˜¯ `LlmToolDispatcherService`ï¼Œè€Œ `EmbeddingDispatcherService` åªæ˜¯ä¸€ä¸ªæœªå®ç°çš„å ä½ç¬¦ã€‚è¿™ä½¿å¾— `Dispatcher` å±‚æˆä¸ºäº†ä¸€ä¸ªå¤šä½™çš„ä¸­é—´å±‚ã€‚
- **æ ¸å¿ƒå†³ç­–**: **å®Œå…¨ç§»é™¤ `IDispatcherService` æŠ½è±¡å±‚åŠå…¶æ‰€æœ‰å®ç°** (`LlmToolDispatcherService`, `EmbeddingDispatcherService`)ã€‚
- **èŒè´£è½¬ç§»**: åŸæœ¬ç”± `LlmToolDispatcherService` è´Ÿè´£çš„â€œè°ƒç”¨LLMè¿›è¡Œå·¥å…·é€‰æ‹©â€çš„èŒè´£ï¼Œå°†**ç›´æ¥ç”± `IntelligentToolCallingService` æ‰¿æ‹…**ã€‚
- **ç†ç”±**:
    - **ç®€åŒ–æ¶æ„**: å‡å°‘ä¸å¿…è¦çš„æŠ½è±¡å’Œæ–‡ä»¶ï¼Œé™ä½è®¤çŸ¥è´Ÿè·ã€‚
    - **æå‡å†…èšæ€§**: `IntelligentToolCallingService` ä½œä¸ºâ€œæ™ºèƒ½ç¼–æ’å¼•æ“â€ï¼Œè‡ªå·±è´Ÿè´£ä¸LLMæ²Ÿé€šæ¥åˆ¶å®šæ‰§è¡Œè®¡åˆ’ï¼Œæ˜¯å®Œå…¨åˆç†çš„ã€‚
    - **éµå¾ªYAGNIåŸåˆ™**: â€œYou Ain't Gonna Need Itâ€ã€‚æˆ‘ä»¬ä¸åº”è¯¥ä¸ºä¸€ä¸ªå½“å‰ä¸å­˜åœ¨çš„éœ€æ±‚ï¼ˆå¤šç§å·¥å…·é€‰æ‹©ç­–ç•¥ï¼‰ä¿ç•™ä¸€ä¸ªæŠ½è±¡å±‚ã€‚

```csharp
// ç®€åŒ–åçš„ IntelligentToolCallingService
public class IntelligentToolCallingService : IIntelligentToolCallingService
{
    private readonly ILLMService _llmService;

    public IntelligentToolCallingService()
    {
        _llmService = CoreServices.LLMService; 
    }

    public async Task ExecuteQueryStreamAsync(string query, Action<string> onChunk, CancellationToken cancellationToken = default)
    {
        var availableTools = CoreServices.GetAvailableTools();
        
        // èŒè´£å†…åŒ–ï¼šç›´æ¥è°ƒç”¨ LLMService è¿›è¡Œå·¥å…·é€‰æ‹©
        var functionCalls = await _llmService.GetFunctionCallAsync(query, availableTools, cancellationToken);
        
        // ... åç»­çš„å·¥å…·æ‰§è¡Œå’Œå“åº”ç”Ÿæˆé€»è¾‘ ...
    }
}
```

## ğŸ“ å®æ–½è®¡åˆ’ (Implementation Plan)

### é˜¶æ®µ1ï¼šServiceContainerå¢å¼º (ä¼˜å…ˆçº§ï¼šé«˜)
1. **æ‰©å±•ServiceContainer**
   - æ·»åŠ å·¥å…·æ³¨å†ŒAPI (`RegisterServiceWithTools`)
   - å®ç°å·¥å…·æ‰§è¡Œå¼•æ“ (`ExecuteToolAsync`)
   - æ·»åŠ å·¥å…·å‘ç°API (`GetFrameworkToolDefinitions`)

2. **åˆ›å»ºå·¥å…·å®šä¹‰ç³»ç»Ÿ**
   - å®ç° `ExecutableTool` å’Œ `ExecutableToolBuilder`
   - å®ç°å‚æ•°éªŒè¯å’Œç±»å‹è½¬æ¢
   - æ·»åŠ ä¸Frameworkçš„å…¼å®¹å±‚

3. **è¿ç§»ç°æœ‰å·¥å…·æ³¨å†Œ**
   - å°† `ToolRegistryService` ä¸­çš„å·¥å…·å®šä¹‰è¿ç§»åˆ°æ–°ç³»ç»Ÿ
   - æ›´æ–°æœåŠ¡æ³¨å†Œæ–¹å¼
   - ç¡®ä¿å‘åå…¼å®¹

### é˜¶æ®µ2ï¼šIntelligentToolCallingServiceé‡æ„ (ä¼˜å…ˆçº§ï¼šé«˜)
1. **ç®€åŒ–å½“å‰å®ç°**
   - ç§»é™¤å¯¹ `IToolRegistryService` çš„ä¾èµ–
   - ç›´æ¥ä½¿ç”¨ `ServiceContainer` çš„å·¥å…·èƒ½åŠ›
   - ä¼˜åŒ–é”™è¯¯å¤„ç†å’Œç”¨æˆ·åé¦ˆ

2. **æ·»åŠ é«˜çº§ç¼–æ’èƒ½åŠ›**
   - å®ç°å·¥å…·é“¾æ‰§è¡Œ (`ExecuteToolChainStreamAsync`)
   - å®ç°å¹¶è¡Œå·¥å…·è°ƒç”¨ (`ExecuteParallelToolsStreamAsync`)
   - æ·»åŠ æ‰§è¡Œè®¡åˆ’åŠŸèƒ½ (`PlanExecutionAsync`)

### é˜¶æ®µ3ï¼šæ¸…ç†å’Œä¼˜åŒ– (ä¼˜å…ˆçº§ï¼šä¸­)
1. **ç§»é™¤å†—ä½™ç»„ä»¶**
   - åˆ é™¤ `IToolRegistryService` å’Œ `ToolRegistryService`
   - æ›´æ–° `CoreServices` é—¨é¢
   - æ¸…ç†ç›¸å…³çš„usingè¯­å¥å’Œä¾èµ–

2. **æ›´æ–°æ–‡æ¡£å’Œç¤ºä¾‹**
   - æ›´æ–°å¼€å‘è€…æŒ‡å—
   - æ›´æ–°APIå‚è€ƒæ–‡æ¡£
   - æ·»åŠ é«˜çº§ä½¿ç”¨ç¤ºä¾‹

### é˜¶æ®µ4ï¼šæµ‹è¯•å’ŒéªŒè¯ (ä¼˜å…ˆçº§ï¼šä¸­)
1. **åŠŸèƒ½æµ‹è¯•**
   - å•å·¥å…·è°ƒç”¨æµ‹è¯•
   - å·¥å…·é“¾è°ƒç”¨æµ‹è¯•
   - å¹¶è¡Œå·¥å…·è°ƒç”¨æµ‹è¯•
   - é”™è¯¯å¤„ç†æµ‹è¯•

2. **æ€§èƒ½ä¼˜åŒ–**
   - å·¥å…·æ‰§è¡Œæ€§èƒ½ä¼˜åŒ–
   - å†…å­˜ä½¿ç”¨ä¼˜åŒ–
   - å¹¶å‘å¤„ç†ä¼˜åŒ–

## ğŸŒŸ æ¶æ„ä¼˜åŠ¿

### 1. æ¸…æ™°çš„èŒè´£åˆ†ç¦»
- **ServiceContainer**: ä¸“æ³¨äº"èƒ½åŠ›ç®¡ç†"ï¼Œä¸æ¶‰åŠ"æµç¨‹ç¼–æ’"
- **IntelligentToolCallingService**: ä¸“æ³¨äº"æ™ºèƒ½ç¼–æ’"ï¼Œä¸æ¶‰åŠ"å·¥å…·æ‰§è¡Œ"
- **Governor**: ä¸“æ³¨äº"ç”¨æˆ·äº¤äº’"ï¼Œä¸æ¶‰åŠ"åº•å±‚é€»è¾‘"

### 2. å¼ºå¤§çš„æ‰©å±•èƒ½åŠ›
- **æ–°å·¥å…·æ·»åŠ **: åªéœ€åœ¨æœåŠ¡æ³¨å†Œæ—¶æ·»åŠ å·¥å…·å®šä¹‰
- **æ–°ç¼–æ’ç­–ç•¥**: åªéœ€åœ¨IntelligentToolCallingServiceä¸­æ·»åŠ æ–°æ–¹æ³•
- **æ–°AIå®˜å‘˜**: å¯ä»¥å¤ç”¨æ•´ä¸ªå·¥å…·è°ƒç”¨åŸºç¡€è®¾æ–½

### 3. ä¼˜ç§€çš„å¼€å‘ä½“éªŒ
- **ç±»å‹å®‰å…¨**: ç¼–è¯‘æ—¶å°±èƒ½å‘ç°å·¥å…·å®šä¹‰é”™è¯¯
- **è‡ªåŠ¨è¡¥å…¨**: IDEèƒ½å¤Ÿæä¾›å®Œæ•´çš„ä»£ç è¡¥å…¨
- **æ˜“äºè°ƒè¯•**: æ¸…æ™°çš„æ‰§è¡Œæµç¨‹å’Œè¯¦ç»†çš„æ—¥å¿—
- **æ˜“äºæµ‹è¯•**: æ¯ä¸ªç»„ä»¶éƒ½æœ‰æ˜ç¡®çš„æ¥å£å’ŒèŒè´£

### 4. é¢å‘æœªæ¥
- **å·¥å…·é“¾æ”¯æŒ**: æ”¯æŒå¤æ‚çš„å¤šæ­¥éª¤ä»»åŠ¡å¤„ç†
- **å¹¶è¡Œå¤„ç†**: æ”¯æŒåŒæ—¶æ‰§è¡Œå¤šä¸ªå·¥å…·
- **æ¡ä»¶åˆ†æ”¯**: æ”¯æŒåŸºäºç»“æœçš„åŠ¨æ€å†³ç­–
- **è¿­ä»£ä¼˜åŒ–**: æ”¯æŒå¤šè½®äº¤äº’å’Œç»“æœæ”¹è¿›

---

## æ–½å·¥æç¤ºè¯ (Implementation Prompt)

**ä»»åŠ¡ï¼š** æ ¹æ®ä¸Šè¿° v3.0 æ¶æ„è®¾è®¡ï¼Œå¯¹ `RimAI.Core` è¿›è¡Œå…¨é¢é‡æ„ã€‚

**æ ¸å¿ƒåŸåˆ™ï¼š**
1. **ServiceContainerä¸ºèƒ½åŠ›ä¸­å¿ƒ**: ç»Ÿä¸€ç®¡ç†æ‰€æœ‰æœåŠ¡å’Œå·¥å…·ï¼Œæä¾›æ‰§è¡Œèƒ½åŠ›
2. **IntelligentToolCallingServiceä¸ºç¼–æ’å¼•æ“**: å¤„ç†å¤æ‚çš„AI-å·¥å…·äº¤äº’æµç¨‹
3. **é¿å…Frameworkå†²çª**: ä½¿ç”¨ä¸åŒçš„ç±»å‹åç§°å’Œæ˜ç¡®çš„èŒè´£è¾¹ç•Œ
4. **ä¿æŒå‘åå…¼å®¹**: åœ¨å¯èƒ½çš„æƒ…å†µä¸‹ä¿æŒç°æœ‰APIçš„å…¼å®¹æ€§

**å…·ä½“å®æ–½æ­¥éª¤ï¼š**

1. **æ‰©å±•ServiceContainer**ï¼š
   - æ·»åŠ  `ExecutableTool` å’Œ `ExecutableToolBuilder` ç±»
   - å®ç° `RegisterServiceWithTools` æ–¹æ³•
   - å®ç° `ExecuteToolAsync` æ–¹æ³•
   - å®ç° `GetFrameworkToolDefinitions` æ–¹æ³•

2. **é‡æ„IntelligentToolCallingService**ï¼š
   - ç§»é™¤å¯¹ `IToolRegistryService` çš„ä¾èµ–
   - ä½¿ç”¨ `ServiceContainer` çš„æ–°API
   - ä¿æŒç°æœ‰çš„ `ExecuteQueryStreamAsync` æ–¹æ³•
   - ä¸ºæœªæ¥çš„é«˜çº§åŠŸèƒ½é¢„ç•™æ¥å£

3. **æ›´æ–°æœåŠ¡æ³¨å†Œ**ï¼š
   - å°†ç°æœ‰çš„å·¥å…·å®šä¹‰è¿ç§»åˆ°æ–°çš„æ³¨å†Œæ–¹å¼
   - ä¿æŒæ‰€æœ‰æœåŠ¡çš„æ­£å¸¸æ³¨å†Œå’Œè¿è¡Œ

4. **æ¸…ç†å·¥ä½œ**ï¼š
   - ç§»é™¤ `IToolRegistryService` åŠå…¶å®ç°
   - æ›´æ–° `CoreServices` é—¨é¢
   - æ›´æ–°ç›¸å…³çš„ä¾èµ–å’Œå¼•ç”¨

5. **éªŒè¯å’Œæµ‹è¯•**ï¼š
   - ç¡®ä¿æ‰€æœ‰ç°æœ‰åŠŸèƒ½æ­£å¸¸å·¥ä½œ
   - éªŒè¯æ–°çš„å·¥å…·æ³¨å†Œå’Œæ‰§è¡Œæœºåˆ¶
   - ç¡®ä¿ Governor èƒ½å¤Ÿæ­£å¸¸å¤„ç†ç”¨æˆ·æŸ¥è¯¢ 